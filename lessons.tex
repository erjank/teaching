\chaplbl{Lessons}{sec:lessons}

So far, we've spent a lot of time talking about details of teaching and
learning.
Yesterday we talked about specific teaching tools and how
people learn; today we've talked about Software Carpentry and Data
Carpentry teaching more specifically.
So to wrap up the training, we're
going to go back and look a bit more at lessons - the actual content
that you will be preparing and teaching as a Software/Data Carpentry
instructor. This will two forms: we'll talk about lesson design
generally, and about the Software and Data Carpentry lessons in
particular.

\seclbl{Writing Lessons}{sec:writing-lessons}

A theme you may have noticed in our material so far is a need to start
``at the end''. To write a multiple-choice question, you have to start
with
misconceptions and work backward to write a question to diagnose
them. To write a faded example, you start with the full example and
remove pieces. So here, the way to write a lesson is not to just sit
down and start writing. The most important thing is to know your
audience and what you want them to learn, and then to develop your
lesson accordingly.

\seclbl{Learner Profiles}{sec:learner-profiles}

The first piece - your audience, can be identified in many ways.
Frequently people who are hosting a workshop have a specific audience in
mind, based on their own experience.

One ``creative'' way to characterize the audience for a course is to
write \emph{learner profiles}. This technique is borrowed from user
interface design, where short profiles of typical users are created to
help designers think about their audience's needs, and to give them a
shorthand for talking about specific cases.

Learner profiles have three parts: the person's general background, the
problem they face, and how the course will help them. A learner profile
for Software Carpentry might be:

\begin{quote}
Jo\~{a}o is an agricultural engineer doing his masters in soil physics. His
programming experience is a first year programming course using C. He
was never able to use this low-level programming into his activities,
and never programmed after the first year.

His work consists of evaluating physical properties of soil samples from
different conditions. Some of the soil properties are measured by an
automated device that sends logs in a text format to his machine. Jo\~{a}o
has to open each file in Excel, crop the first and last quarters of
points, and calculate an average.

Software Carpentry will show Jo\~{a}o how to write shell scripts to count
the lines and crop the right range for each file, and how to use R to
read these files and calculate the required statistics. It will also
show him how to put his programs and files under version control so that
he can re-run analyses and figure out which results may have been
affected by changes.
\end{quote}

\begin{challenge}{Learner Profiles}{chal:learner-profiles}

Read \href{http://software-carpentry.org/audience/}{Software Carpentry's
learner profiles} and then write one that describes a fictional
colleague of your own. Who are they, what problems do they face, and how
will this training help them? Try to be as specific as possible.
\end{challenge}

\seclbl{Writing Learning Objectives}{sec:writing-learning-objectives}

Summative and formative assessments help instructors figure out what
they're going to teach, but in order to communicate that to learners and
other instructors, we should also write \emph{learning objectives}. A
learning objective is a single sentence describing what a learner will
be able to do once they have sat through the lesson, in order to
demonstrate ``learning.'' That requires thinking critically about what
exactly you want people to learn.

It's dangerously easy to come up with fuzzy learning objectives. A broad
statement like ``Understand git'' could mean many different specific
goals, like:

\begin{itemize}
\item
  Learners can revert a change to a file using git.
\item
  Learners will name three benefits of using a version control system
  like git.
\item
  Learners will compare the collaboration features of git and dropbox.
\end{itemize}

What we want are specific, verifiable descriptions of what learners can
do to demonstrate their learning. Each learning objective should have
\emph{a measurable or verifiable verb} specifying what the learner will
do, and should specify the \emph{criteria for acceptable performance}.

Writing these kinds of learning objectives may seem restrictive or
limiting, but will make both you and your learners happier in the long
run. You will end up with clear guidelines for both your teaching and
assessment, and your learners will appreciate the clear expectations.

In order to formulate good learning objectives we need to decide what
kinds of learning we are aiming for. There is a difference between
knowing the atomic weight of fluorine and understanding what elements
it's likely to bond with and why. Similarly, there's a difference
between being able to figure out why a microscope isn't focusing
properly and being able to design a new microscope that focuses more
easily. What we need is a taxonomy of understanding that is
hierarchical, measurable, stable, and cross-cultural.

The best-known attempt to build one is
\href{https://en.wikipedia.org/wiki/Bloom's\_taxonomy}{Bloom's taxonomy},
which was first published in 1956. More recent efforts are Wiggins and
McTighe's \emph{facets of understanding} \cite{bib:wiggins-mctighe} and Fink's taxonomy
\cite{bib:fink-csle}. \tblref{tbl:bloom}
shows some of the verbs typically used in learning objectives written
for each of Bloom et al's original levels.

\begin{tbllbl}{Bloom's Taxonomy}{tbl:bloom}

\begin{enumerate}

\item Knowledge: recalling learned information

\item Comprehension: explaining the meaning of information

\item Application: applying what one knows to novel, concrete situations

\item Analysis: breaking down a whole into its component parts and explaining how each part contributes to the whole

\item Synthesis: assembling components to form a new and integrated whole

\item Evaluation: using evidence to make judgments about the relative merits of ideas and materials

\end{enumerate}

\end{tbllbl}

\fixme{What needs to be in a good learning objective?}
Here is an example of a successively-improved lesson objective:

\begin{tabular}{ll}

Learner will be given opportunities to learn good programming practices.
&
Describes the lesson's content, not the attributes of successful students.
\\

Learner will have a better appreciation for good programming practices.
&
Doesn't start with an active verb or define the level of learning,
and the subject of learning has no context and is not specific.
\\

Learner will understand principles of good programming.
&
Starts with an active verb, but doesn't define the level of learning,
and the subject of learning is still too vague for assessment.
\\

Learner will write one-page data analysis scripts for research purposes using R Studio.
&
Starts with an active verb, defines the level of learning,
and provides context to ensure that outcomes can be assessed.
\\

\end{tabular}

Baume's guide to
writing and using good learning outcomes \cite{bib:baume-fixme} is a good longer discussion of these
issues.

\begin{challenge}{Evaluate SWC and DC Learning Objectives}{chal:evaluate-swc-and-dc-learning-objectives}

Your instructor has posted links to a handful of current Software and
Data Carpentry lessons in the Etherpad. Take a minute to select one
learning objective from one of those lessons, then complete the
following steps to evaluate it and reword it to make it sharper.

\begin{enumerate}
\item
  Identify the learning objective verb.
\item
  Decide what type of learning outcome this applies to
  (i.e.~comprehension, application, evaluation).
\item
  Reword the learning objective for a different learning outcome (e.g.,
  from application to knowledge based outcome or vice versa).
\item
  Pair up to discuss your rewording or help each other with point 3 or 4
  if necessary.
\item
  Share the original and your re-worded learning objectives in the Etherpad.
\end{enumerate}
\end{challenge}

\seclbl{Reverse Instructional Design}{sec:reverse-instructional-design}

Most people design courses as follows:

\begin{enumerate}
\item
  The chair tells you that you have to teach something you haven't
  thought about in ten years.
\item
  You start writing slides to explain what you know about the subject.
\item
  After two or three weeks, you make up an assignment based more or less
  on what you've taught so far.
\item
  You repeat step 3 several times.
\item
  You stay up 'til the wee hours to make up a final exam.
\end{enumerate}

There's a better way, and to explain it, we first need to explain how
\emph{\href{https://en.wikipedia.org/wiki/Test-driven\_development}{test-driven
development}} (TDD) is used in software development. When programmers
are using TDD, they don't write software and then (possibly) write
tests. Instead, they write the tests first, then write just enough new
software to make those tests pass, and then clean up a bit.

TDD works because writing tests forces programmers to specify exactly
what they're trying to accomplish and what ``done'' looks like. It's
easy to be vague when using a human language like English or Korean;
it's much harder to be vague in Python or R.

TDD also reduces the risk of endless polishing, and increases the
likelihood that tests will actually get written. (Somehow, people always
seem to run out of time\ldots{}) Finally, writing the tests first
reduces the risk of confirmation bias: someone who hasn't written a
program is much more likely to be objective when testing it than its
original author.

A similar ``backward'' method works very well for lesson design. As
described in Wiggins and McTighe's
\emph{\href{http://www.amazon.com/Understanding-Design-Expanded-Grant-Wiggins/dp/0131950843/}{Understanding
by Design}}, the method proceeds through four stages:

\begin{enumerate}
\item
  Identify what is worth learning (e.g., draw concept maps).
\item
  Decide what constitutes evidence that learning has taken place (i.e.,
  create the final exam or some other summative assessment).
\item
  Design practice work to prepare learners for what they will have to do
  during the summative assessment. These should include formative
  assessments to be done in class and the exercises to be done out of
  class.
\item
  Sort those practices in order of increasing complexity and then write
  short episodes to close the gap between what learners know and what
  they need to know in order to do each one. (An actual classroom lesson
  will then consist of several such episodes, each building toward a
  quick formative assessment.)
\end{enumerate}

This \emph{reverse instructional design} method helps keep teaching
focused on its objectives. It also ensures that learners don't face
anything on the final exam that the course hasn't prepared them for.

\begin{callout}{How and Why to Fake It}{callout:how-and-why-to-fake-it}

One of the most influential papers in the history of software
engineering was Parnas and Clements'
``\href{http://dx.doi.org/10.1109/TSE.1986.6312940}{A Rational Design
Process: How and Why to Fake It}''
(\href{http://www.ics.uci.edu/~taylor/classes/121/IEEE86\_Parnas\_Clement.pdf}{PDF}),
in which they pointed out that in real life we move back and forth
between gathering requirements, interface design, programming, and
testing, but when we write up our work it's important to describe it as
if we did these steps one after another so that other people can retrace
our steps. The same is true of lesson design: while we may change our
mind about what we want to teach based on something that occurs to us
while we're writing an MCQ, we want the notes we leave behind to present
things in the order described above.
\end{callout}

\begin{discussion}{Teaching to the Test}{discuss:teaching-to-the-test}

Is reverse instructional design ``teaching to the test''? I.e., does it
steer teachers toward getting their students to pass an exam rather than
learn things?

Reverse instructional design is \emph{not} the same thing as ``teaching
to the test''. When using RID, teachers set goals to aid in lesson
design, and may never actually give the final exam that they wrote. In
many school systems, on the other hand, an external authority defines
assessment criteria for all learners, regardless of their individual
situations, and the outcomes of those summative assessments directly
affect the teachers' pay and promotion. Green's
\emph{\href{http://www.amazon.com/Building-Better-Teacher-Teaching-Everyone/dp/0393351084/}{Building
a Better Teacher}} argues that this focus on measurement is appealing to
those with the power to set the tests, but is unlikely to improve
outcomes unless it is coupled with support for teachers to make
improvements based on test outcomes. This is often missing, because as
Scott pointed out in
\emph{\href{http://www.amazon.com/Seeing-like-State-Certain-Condition/dp/0300078153/}{Seeing
Like a State}}, large organizations usually value uniformity over
productivity. \{: .solution\}
\end{discussion}

\begin{callout}{The Minimal Manual}{callout:the-minimal-manual}

Carroll et al's 1987 paper
``The Minimal Manual'' \cite{bib:carroll-minimal-manual}
outlines an approach to documentation and instruction
in which each lesson is one page long and describes how to accomplish
one concrete task. Its focus on immediate application, error recognition
and recovery, and reference use after training makes it an interesting
model for Software and Data Carpentry.
\end{callout}

\seclbl{Software and Data Carpentry Lessons}{sec:software-and-data-carpentry-lessons}

It would be nice to say that the Software and Data Carpentry lessons
were all developed using perfect reverse instructional design. While
that's not necessarily true, all of the lessons are constantly being
revised and edited with certain core objectives in mind.

The main aim of the Unix shell lesson is to familiarize people with a
handful of basic concepts that crop up in many other areas of computing:

\begin{itemize}
\item
  the notions of a path and a home directory
\item
  the use of history and tab completion to save time (and prevent
  mistakes)
\item
  manipulating text using \texttt{head}, \texttt{tail}, \texttt{grep},
  and related tools
\item
  combining existing tools using pipes instead of writing new ones
\item
  using loops to repeat operations
\end{itemize}

The aims of the version control lesson are to teach people:

\begin{itemize}
\item
  how to keep track of their work,
\item
  how to collaborate with other people online, and
\item
  enough about privacy and licensing that they can begin to make
  sensible decisions about what to put where and how to share it.
\end{itemize}

The ostensible aim of the programming lessons are to show people how to
build modular programs out of small functions that can be read, tested,
and re-used. However, these concepts turn out to be hard to convey to
people who are still learning the syntax of a programming language
(forest and trees), so in practice the programming lessons focus
primarily on the mechanics of doing common operations in those
languages.

\seclbl{Data Carpentry}{sec:data-carpentry}

Data Carpentry's \href{http://datacarpentry.org/lessons/}{lessons}
are domain-specific and cover data organization, manipulation, and
visualization skills relevant to the target domain. These goals include:

\begin{itemize}
\item
  \href{http://datacarpentry.org/lessons/\#ecology-workshop}{Ecology}

  \begin{itemize}
    \item
    Focuses on general data management skills (proper data formatting
    and tracking) and tools for manipulating and visualizing tabular
    data.
  \end{itemize}
\item
  \href{http://datacarpentry.org/lessons/\#genomics-workshop}{Genomics}

  \begin{itemize}
    \item
    Specialized for researchers with sequence data, includes specific
    bioinformatics tools and how to use large-scale computing
    resources.
  \end{itemize}
\item
  \href{http://datacarpentry.org/lessons/\#geospatial-data-workshop}{Geospatial
  Data}
\end{itemize}

There are also materials in development and testing for:

\begin{itemize}
\item
  \href{http://datacarpentry.org/lessons/\#social-science-materials}{Social
  Science}
\item
  and \href{http://datacarpentry.org/semester-biology/}{a
  semester-long Biology course}.
\end{itemize}

Other Data Carpentry lessons are in the incubator stage.

\begin{quote}
How practical do you think it would be to use the techniques you've
learned in this workshop in regular teaching? In particular, do you
think you would have enough time to prepare and teach lessons the ways
you have been shown?
\end{quote}
